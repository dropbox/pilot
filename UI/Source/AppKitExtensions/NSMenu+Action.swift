import AppKit
import Pilot

extension NSMenu {

    /// Returns a `NSMenu` configured from the given `SecondaryAction` array. The given action will be invoked for
    /// each menu item selection. The receiver can call `NSMenuItem.representedAction` to get the action represented
    /// by the menu item in the implementation of the provided selector.
    public static func fromSecondaryActions(
        _ actions: [SecondaryAction],
        action: Selector,
        target: AnyObject? = nil
    ) -> NSMenu {
        let menu = NSMenu()

        // Enabling is set explicitly per-item below.
        menu.autoenablesItems = false

        actions.forEach {
            let menuItem = NSMenuItem.fromSecondaryAction($0, action: action, target: target)
            menu.addItem(menuItem)
        }

        return menu
    }
}

extension NSMenuItem {

    /// Returns the `Action` represented by a menu item created via `NSMenu.fromSecondaryActions(action:)` so that
    /// it may be sent.
    public var representedAction: Action? {
        if let wrapper = representedObject as? MenuItemActionWrapper {
            return wrapper.wrappedAction
        }
        return nil
    }

    /// Useful for reusing common portions of a Menu by generating menuItems that can be inserted later.
    /// Avoids the issue of needing to migrate items from an NSMenu generated by NSMenu.fromSecondaryActions(...)
    public static func fromSecondaryAction(
        _ secondaryAction: SecondaryAction,
        action: Selector,
        target: AnyObject? = nil
    ) -> NSMenuItem {
        switch secondaryAction {
        case .action(let info):
            let menuItem = NSMenuItem(
                title: info.metadata.title,
                action: action,
                keyEquivalent: info.metadata.keyEquivalent)
            menuItem.isEnabled = info.metadata.enabled
            menuItem.state = info.metadata.state.toNSState()
            menuItem.representedObject = MenuItemActionWrapper(info.action)
            if let imageName =  info.metadata.imageName {
                menuItem.image = NSImage(named: imageName)
            }
            menuItem.target = target
            return menuItem

        case .info(let string):
            let menuItem = NSMenuItem(title: string, action: action, keyEquivalent: "")
            menuItem.isEnabled = false
            menuItem.state = NSOffState
            menuItem.target = target
            return menuItem

        case .separator:
            return NSMenuItem.separator()

        case .nested(let info):
            let menuItem = NSMenuItem(
                title: info.metadata.title,
                action: nil,
                keyEquivalent: info.metadata.keyEquivalent)
            menuItem.isEnabled = info.metadata.enabled
            if let imageName =  info.metadata.imageName {
                menuItem.image = NSImage(named: imageName)
            }
            menuItem.target = target    // There is no action, but target can be used for validation.
            menuItem.submenu = NSMenu.fromSecondaryActions(info.actions, action: action, target: target)
            return menuItem
        }
    }
}

public extension SecondaryActionInfo.Metadata.State {
    func toNSState() -> Int {
        switch self {
        case .on:
            return NSOnState
        case .mixed:
            return NSMixedState
        case .off:
            return NSOffState
        }
    }
}

/// Helper class to wrap value-type `Action`s.
fileprivate final class MenuItemActionWrapper: NSObject {

    fileprivate convenience init(_ action: Action) {
        self.init()
        wrappedAction = action
    }
    fileprivate var wrappedAction: Action?
}

